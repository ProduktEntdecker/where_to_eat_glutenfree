#!/usr/bin/env bash

# Pre-commit security guard
# Prevents committing secrets, runs security checks
# Usage: ./pre-commit (automatically called by git)

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}üîí $1${NC}"
}

log_warn() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

log_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

# Patterns to detect secrets
SECRET_PATTERNS=(
    "AKIA[0-9A-Z]{16}"                          # AWS Access Key
    "sk-[a-zA-Z0-9]{24,}"                       # OpenAI API Key
    "AIza[0-9A-Za-z\\-_]{35}"                   # Google API Key
    "ya29\\.[0-9A-Za-z\\-_]+"                   # Google OAuth
    "sk_live_[0-9a-zA-Z]{24}"                   # Stripe Live Key
    "sk_test_[0-9a-zA-Z]{24}"                   # Stripe Test Key
    "ghp_[A-Za-z0-9_]{36}"                      # GitHub Personal Access Token
    "mongodb\\+srv://[^\\s/]+:[^\\s/]+@"        # MongoDB Connection String
    "postgres://[^\\s/]+:[^\\s/]+@"             # PostgreSQL Connection String
    "BEGIN.*PRIVATE.*KEY"                       # Private Keys (PEM format)
)

check_secrets() {
    log_info "Scanning for secrets in staged files..."

    local exit_code=0
    local staged_files

    # Get staged files
    staged_files=$(git diff --cached --name-only)

    if [[ -z "$staged_files" ]]; then
        log_info "No staged files to check"
        return 0
    fi

    # Check each staged file for secrets (exclude security scripts)
    while IFS= read -r file; do
        if [[ -f "$file" && ! "$file" =~ scripts/hooks/ ]]; then
            for pattern in "${SECRET_PATTERNS[@]}"; do
                if git diff --cached "$file" | grep -E -q "$pattern"; then
                    log_error "Potential secret detected in $file"
                    log_error "Pattern matched: $pattern"
                    exit_code=1
                fi
            done
        fi
    done <<< "$staged_files"

    return $exit_code
}

check_file_permissions() {
    log_info "Checking file permissions..."

    local exit_code=0

    # Check for files with execute permissions that shouldn't have them
    while IFS= read -r file; do
        if [[ -f "$file" && "$file" =~ \.(json|md|txt|yml|yaml)$ ]]; then
            if [[ -x "$file" ]]; then
                log_warn "Removing execute permission from $file"
                chmod -x "$file"
                git add "$file"
            fi
        fi
    done <<< "$(git diff --cached --name-only)"

    return $exit_code
}

check_large_files() {
    log_info "Checking for large files..."

    local exit_code=0
    local max_size=$((10 * 1024 * 1024)) # 10MB

    while IFS= read -r file; do
        if [[ -f "$file" ]]; then
            local size
            size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
            if [[ $size -gt $max_size ]]; then
                log_error "Large file detected: $file ($(($size / 1024 / 1024))MB)"
                log_error "Consider using Git LFS for files larger than 10MB"
                exit_code=1
            fi
        fi
    done <<< "$(git diff --cached --name-only)"

    return $exit_code
}

main() {
    log_info "Pre-commit security guard - Starting validation"

    local exit_code=0

    # Run all checks
    if ! check_secrets; then
        exit_code=1
    fi

    if ! check_file_permissions; then
        exit_code=1
    fi

    if ! check_large_files; then
        exit_code=1
    fi

    if [[ $exit_code -eq 0 ]]; then
        log_info "Pre-commit security validation passed"
    else
        log_error "Pre-commit security validation failed"
        log_error "Commit blocked for security reasons"
    fi

    return $exit_code
}

# Allow script to be sourced or executed
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi